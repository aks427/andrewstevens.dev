{"version":3,"sources":["webpack:///./src/examples/formula-parser-in-javascript/SyntaxTokenizer.js","webpack:///./src/examples/formula-parser-in-javascript/Functions.js","webpack:///./src/examples/formula-parser-in-javascript/Validation.js","webpack:///./src/examples/formula-parser-in-javascript/FormulaEditor.js","webpack:///./src/examples/formula-parser-in-javascript/Lexer.js","webpack:///./src/examples/formula-parser-in-javascript/NodeGenerator.js","webpack:///./src/examples/formula-parser-in-javascript/Evaluator.js","webpack:///./src/examples/formula-parser-in-javascript/useForm.js","webpack:///./src/pages/posts/formula-parser-in-javascript/example/index.js"],"names":["SyntaxTokenizer","stream","peek","previousToken","getPreviousToken","previousTokenType","type","next","value","match","tokenIsValue","indexOf","token","operators","params","join","Number","functions","upper","length","toUpperCase","round","Math","checkIfValueIsAllowed","FormulaEditor","props","onChange","onErrorsChanged","onTokensChanged","inputRef","useRef","formattedRef","textareaHeight","setTextareaHeight","useState","tokens","setTokens","errors","setErrors","useEffect","t","formula","syntaxTokenizer","position","isEnd","substring","pattern","consume","i","startingPosition","tokenType","Error","push","Lexer","e","unclosedTokens","functionLevel","nonWhitespaceTokens","filter","error","name","toLowerCase","text","pop","unclosedToken","reversedToken","ValidateTokens","useLayoutEffect","inputRefCurrent","current","onInputScroll","scrollTop","scrollLeft","addEventListener","removeEventListener","style","height","min","scrollHeight","___EmotionJSX","className","v","target","replace","ref","autoComplete","autoCorrect","autoCapitalize","spellCheck","rows","formattedText","classNames","x","key","formatText","addNode","nodes","node","lastNode","innerNodes","getInnerTokens","innerTokens","innerBrackets","EvaluateTokens","input","CreateNodesFromTokens","innerTokenResult","slice","console","log","JSON","stringify","result","EvaluateNode","parameters","map","operator","method","ExecuteOperator","ExecuteFunction","reducer","previousState","action","state","obj","parse","deepClone","propertyName","setFormula","inputValues","setInputValue","initialState","formState","dispatch","useReducer","setValue","useForm","references","a","GetReferencesFromTokens","Layout","Helmet","href"],"mappings":"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","file":"component---src-pages-posts-formula-parser-in-javascript-example-index-js-d5944bfe1e261dc1c9c9.js","sourcesContent":["export function SyntaxTokenizer(stream) {\n  const peek = stream.peek();\n  const previousToken = stream.getPreviousToken();\n  const previousTokenType = previousToken ? previousToken.type : null;\n\n  // handle double quotes\n  if (peek === '\"') {\n    stream.next();\n    if (previousTokenType === 'string' || previousTokenType === 'start quote') {\n      return 'end quote';\n    }\n    return 'start quote';\n  }\n\n  // handle strings inside of quotes\n  if (peek !== '\"' && previousTokenType === 'start quote' && previousToken.value === '\"') {\n    if (stream.match(/^[^\"]+(?=\")/, true)) {\n      return 'string';\n    } else {\n      // didn't find end quote so select all the way to the end\n      stream.match(/^[^\"]+/, true);\n      return 'string';\n    }\n  }\n\n  // handle numbers\n  if (stream.match(/^[-]?\\d*\\.?\\d+/, false)) {\n    if (peek === '-' && previousTokenType !== 'operator' && tokenIsValue(previousToken)) {\n      // if this number is starting with a minus and there is no previous operator, then we need to be treating this as an operator instead\n      stream.next();\n      return 'operator';\n    }\n    stream.match(/^[-]?\\d*\\.?\\d+/, true);\n    return 'number';\n  }\n\n  // handle operators\n  if (['&', '*', '-', '+', '/'].indexOf(peek) > -1) {\n    stream.next();\n    return 'operator';\n  }\n\n  // handle references\n  if (previousTokenType === 'bracket' && previousToken.value === '[' && stream.match(/^[^[\\]]+(?=\\])/, true)) {\n    return 'reference-name';\n  }\n\n  // handle functions\n  if (stream.match(/^[a-zA-Z_]\\w*(?=\\()/, true)) {\n    return 'function-name';\n  }\n\n  // handle brackets\n  if ([')', ']', '(', '['].indexOf(peek) > -1) {\n    stream.next();\n    return 'bracket';\n  }\n\n  // handle comma\n  if (peek === ',') {\n    stream.next();\n    return 'comma';\n  }\n\n  // handle whitespace\n  if (stream.match(/^ +/, true)) {\n    return 'whitespace';\n  }\n\n  // mark anything else as an error\n  stream.next();\n  return 'error';\n}\n\nexport function tokenIsValue(token) {\n  if (!token) {\n    return false;\n  }\n  if (token.type === 'number' || token.type === 'end quote') {\n    return true;\n  }\n  if (token.type === 'bracket' && (token.value === ')' || token.value === ']')) {\n    return true;\n  }\n  return false;\n}\n","const operators = {\n  '&': Concatenate,\n  '+': Add,\n  '-': Subtract,\n  '/': Divide,\n  '*': Multiply,\n};\n\nexport function ExecuteOperator(operator, parameters) {\n  const method = operators[operator];\n  if (method) {\n    return method(parameters);\n  }\n  return '';\n}\n\nconst functions = {\n  upper: Upper,\n  round: Round,\n};\n\nexport function ExecuteFunction(name, parameters) {\n  const method = functions[name.toLowerCase()];\n  if (method) {\n    return method(parameters);\n  }\n  return '';\n}\n\nexport function HasFunction(name) {\n  return !!functions[name.toLowerCase()];\n}\n\nfunction Concatenate(params) {\n  return params.join('');\n}\n\nfunction Add(params) {\n  return Number(params[0]) + Number(params[1]);\n}\n\nfunction Subtract(params) {\n  return Number(params[0]) - Number(params[1]);\n}\n\nfunction Divide(params) {\n  return Number(params[0]) / Number(params[1]);\n}\n\nfunction Multiply(params) {\n  return Number(params[0]) * Number(params[1]);\n}\n\nfunction Upper(params) {\n  if (params.length > 0) {\n    return params[0].toUpperCase();\n  }\n  return '';\n}\n\nfunction Round(params) {\n  if (params.length > 0) {\n    return Math.round(params[0]);\n  }\n  return '';\n}\n","import { HasFunction } from './Functions';\nimport { tokenIsValue } from './SyntaxTokenizer';\n\nexport function ValidateTokens(tokens) {\n  const errors = [];\n  const unclosedTokens = [];\n  let previousToken = null;\n  let functionLevel = 0;\n  const nonWhitespaceTokens = tokens.filter(token => token.type !== 'whitespace');\n\n  for (let i = 0; i < nonWhitespaceTokens.length; i++) {\n    const token = nonWhitespaceTokens[i];\n\n    const previousTokenType = previousToken ? previousToken.type : null;\n\n    if (token.type === 'operator') {\n      if (!tokenIsValue(previousToken)) {\n        errors.push({ token, error: `Unexpected operator '${token.value}'` });\n      }\n      if (i === nonWhitespaceTokens.length - 1) {\n        errors.push({ token, error: `Value expected after operator '${token.value}'` });\n      }\n    }\n\n    if (token.type === 'number') {\n      if (!checkIfValueIsAllowed(previousToken)) {\n        errors.push({ token, error: 'An operator is required before the number' });\n      }\n    }\n\n    if (token.type === 'function-name') {\n      if (!checkIfValueIsAllowed(previousToken)) {\n        errors.push({ token, error: 'An operator is required before the function' });\n      }\n\n      if (!HasFunction(token.value)) {\n        errors.push({ token, error: `'${token.value}' is not a valid function` });\n      }\n    }\n\n    if (token.type === 'start quote') {\n      unclosedTokens.push({ text: '\"', type: 'reference', token });\n\n      if (!checkIfValueIsAllowed(previousToken)) {\n        errors.push({ token, error: 'An operator is required before the string' });\n      }\n    }\n\n    if (token.type === 'end quote') {\n      if (unclosedTokens.length > 0 && unclosedTokens[unclosedTokens.length - 1].text === '\"') {\n        unclosedTokens.pop();\n      }\n    }\n\n    if (token.type === 'comma') {\n      if (!functionLevel > 0) {\n        errors.push({ token, error: `Unexpected ','` });\n      }\n      if (!tokenIsValue(previousToken)) {\n        errors.push({ token, error: `Unexpected ','` });\n      }\n    }\n\n    if (token.type === 'bracket') {\n      if (token.value === '(') {\n        unclosedTokens.push({ text: '(', type: previousTokenType === 'function-name' ? 'function' : 'group', token });\n\n        if (previousTokenType === 'function-name') {\n          functionLevel += 1;\n        }\n\n        if (previousTokenType !== 'function-name' && !checkIfValueIsAllowed(previousToken)) {\n          errors.push({ token, error: 'An operator is required before the parenthesis' });\n        }\n      }\n\n      if (token.value === ')') {\n        if (unclosedTokens.length > 0 && unclosedTokens[unclosedTokens.length - 1].text === '(') {\n          if (unclosedTokens[unclosedTokens.length - 1].type === 'function') {\n            functionLevel--;\n          }\n\n          unclosedTokens.pop();\n\n          if (!tokenIsValue(previousToken) && !(previousTokenType === 'start-parenthesis' && unclosedTokens[unclosedTokens.length - 1].type === 'function')) {\n            errors.push({ token, error: `Unexpected ')'` });\n          }\n        } else {\n          errors.push({ token, error: `Unexpected ')'` });\n        }\n      }\n\n      if (token.value === '[') {\n        unclosedTokens.push({ text: '[', type: 'reference', token });\n\n        if (!checkIfValueIsAllowed(previousToken)) {\n          errors.push({ token, error: 'An operator is required before the reference' });\n        }\n      }\n\n      if (token.value === ']') {\n        if (unclosedTokens.length > 0 && unclosedTokens[unclosedTokens.length - 1].text === '[') {\n          if (previousTokenType !== 'reference-name') {\n            errors.push({ token, error: 'A reference name is required in the brackets' });\n          }\n          unclosedTokens.pop();\n        } else {\n          errors.push({ token, error: `Unexpected ']'` });\n        }\n      }\n    }\n\n    previousToken = token;\n  }\n\n  for (const unclosedToken of unclosedTokens) {\n    let reversedToken = unclosedToken.text;\n    if (unclosedToken.text === '(') {\n      reversedToken = ')';\n    } else if (unclosedToken.text === '[') {\n      reversedToken = ']';\n    }\n    errors.push({ token: unclosedToken.token, error: `Missing closing '${reversedToken}'` });\n  }\n\n  return errors;\n}\n\nfunction checkIfValueIsAllowed(previousToken) {\n  if (!previousToken) {\n    return true;\n  }\n\n  if (previousToken.type === 'operator' || previousToken.type === 'comma' || (previousToken.type === 'bracket' && previousToken.value === '(')) {\n    return true;\n  }\n  return false;\n}\n","import React, { useEffect, useLayoutEffect, useRef, useState } from 'react';\nimport { Lexer } from './Lexer';\nimport { SyntaxTokenizer } from './SyntaxTokenizer';\nimport { ValidateTokens } from './Validation';\nimport './FormulaEditor.scss';\n\nexport function FormulaEditor(props) {\n  const { value, onChange, onErrorsChanged, onTokensChanged } = props;\n  const inputRef = useRef();\n  const formattedRef = useRef();\n  const [textareaHeight, setTextareaHeight] = useState(30);\n  const [tokens, setTokens] = useState([]);\n  const [errors, setErrors] = useState([]);\n\n  useEffect(() => {\n    const t = Lexer(value, SyntaxTokenizer);\n    const e = ValidateTokens(t);\n    setTokens(t);\n    setErrors(e);\n    if (onTokensChanged) {\n      onTokensChanged(t);\n    }\n    if (onErrorsChanged) {\n      onErrorsChanged(e);\n    }\n  }, [value, onTokensChanged, onErrorsChanged]);\n\n  useLayoutEffect(() => {\n    const inputRefCurrent = inputRef.current;\n    const onInputScroll = () => {\n      formattedRef.current.scrollTop = inputRef.current.scrollTop;\n      formattedRef.current.scrollLeft = inputRef.current.scrollLeft;\n    };\n\n    inputRefCurrent.addEventListener('scroll', onInputScroll);\n    return () => {\n      inputRefCurrent.removeEventListener('scroll', onInputScroll);\n    };\n  }, [inputRef]);\n\n  useLayoutEffect(() => {\n    const updateInputHeight = () => {\n      inputRef.current.style.height = 'auto';\n      inputRef.current.style.height = `${Math.min(inputRef.current.scrollHeight + 2, 200)}px`;\n      setTextareaHeight(inputRef.current.scrollHeight + 2); // add 1px for top and bottom borders\n    };\n\n    updateInputHeight();\n  }, [value]);\n\n  const textareaOnChange = e => {\n    let v = e.target.value;\n    if (v) {\n      // disable multiline\n      v = v.replace(/(?:\\r\\n|\\r|\\n)/g, '');\n    }\n    onChange(v);\n  };\n\n  return (\n    <div className=\"formula-editor\">\n      <textarea\n        value={value}\n        onChange={textareaOnChange}\n        className=\"formula-editor-textarea\"\n        ref={inputRef}\n        autoComplete=\"off\"\n        autoCorrect=\"off\"\n        autoCapitalize=\"off\"\n        spellCheck=\"false\"\n        height={textareaHeight}\n        rows={1}\n      />\n      <div className=\"formula-editor-formatted\" ref={formattedRef}>\n        {formatText(tokens, errors)}\n      </div>\n    </div>\n  );\n}\n\nfunction formatText(tokens, errors) {\n  let formattedText = [];\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const classNames = [token.type];\n\n    const errorsForToken = errors.filter(x => x.token === token);\n    if (errorsForToken.length > 0) {\n      classNames.push('error');\n    }\n\n    formattedText.push(\n      <span key={i} className={classNames.join(' ')}>\n        {token.value}\n      </span>\n    );\n  }\n\n  return formattedText;\n}\n","export function Lexer(formula, syntaxTokenizer) {\n  let position = 0;\n  const tokens = [];\n\n  const isEnd = () => {\n    return position >= formula.length;\n  };\n  const peek = () => {\n    if (isEnd()) {\n      return null;\n    }\n    return formula.substring(position, position + 1);\n  };\n  const match = (pattern, consume) => {\n    const restOfFormula = formula.substring(position);\n    const match = restOfFormula.match(pattern);\n    if (!match || match.length > 1) {\n      return null;\n    }\n    if (consume) {\n      position += match[0].length;\n    }\n    return match[0] || null;\n  };\n  const next = () => {\n    position += 1;\n    return peek();\n  };\n  const getPreviousToken = () => {\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      if (tokens[i].type !== 'whitespace') {\n        return tokens[i];\n      }\n    }\n    return null;\n  };\n\n  while (!isEnd()) {\n    const startingPosition = position;\n    const tokenType = syntaxTokenizer({ peek, match, next, isEnd, getPreviousToken });\n\n    if (startingPosition === position) {\n      throw new Error('Tokenizer did not move forward');\n    }\n\n    const token = {\n      value: formula.substring(startingPosition, position),\n      type: tokenType,\n    };\n\n    tokens.push(token);\n  }\n\n  return tokens;\n}\n","export function CreateNodesFromTokens(tokens) {\n  const nodes = [];\n  const nonWhitespaceTokens = tokens.filter(token => token.type !== 'whitespace');\n\n  for (let i = 0; i < nonWhitespaceTokens.length; i++) {\n    const token = nonWhitespaceTokens[i];\n\n    if (['start quote', 'end quote'].indexOf(token.type) > -1) {\n      continue;\n    }\n\n    if (['string', 'number'].indexOf(token.type) > -1) {\n      addNode(nodes, {\n        type: token.type,\n        value: token.value,\n      });\n    }\n\n    if (token.type === 'operator') {\n      const lastNode = nodes[nodes.length - 1];\n      nodes.pop();\n      nodes.push({\n        type: 'operator',\n        value: token.value,\n        innerNodes: [lastNode],\n      });\n    }\n\n    if (token.type === 'reference-name') {\n      addNode(nodes, {\n        type: 'reference',\n        value: token.value,\n      });\n    }\n\n    if (token.type === 'function-name') {\n      let innerTokens = [];\n\n      // move forward past the function name\n      i++;\n\n      if (nonWhitespaceTokens[i] && nonWhitespaceTokens[i].type === 'bracket' && nonWhitespaceTokens[i].value === '(') {\n        const innerTokenResult = getInnerTokens(nonWhitespaceTokens.slice(i));\n        innerTokens = innerTokenResult.tokens;\n        i += innerTokenResult.i;\n      }\n\n      addNode(nodes, {\n        type: 'function',\n        value: token.value,\n        innerNodes: CreateNodesFromTokens(innerTokens),\n      });\n    }\n\n    if (token.type === 'bracket' && token.value === '(') {\n      const innerTokenResult = getInnerTokens(nonWhitespaceTokens.slice(i));\n      i += innerTokenResult.i;\n      const innerTokens = innerTokenResult.tokens;\n\n      addNode(nodes, {\n        type: 'group',\n        innerNodes: innerTokens ? CreateNodesFromTokens(innerTokens) : null,\n      });\n    }\n  }\n  console.log(JSON.stringify(nodes));\n  return nodes;\n}\n\nfunction addNode(nodes, node) {\n  const lastNode = nodes[nodes.length - 1];\n  if (lastNode && lastNode.type === 'operator' && lastNode.innerNodes.length < 2) {\n    lastNode.innerNodes.push(node);\n  } else {\n    nodes.push(node);\n  }\n}\n\nfunction getInnerTokens(tokens) {\n  const innerTokens = [];\n  const innerBrackets = [];\n  let i;\n  for (i = 0; i < tokens.length; i++) {\n    if (tokens[i].type === 'bracket') {\n      if (tokens[i].value === ')' && innerBrackets[innerBrackets.length - 1] === '(') {\n        innerBrackets.pop();\n\n        if (innerBrackets.length === 0) {\n          i++;\n          break;\n        }\n      }\n      if (tokens[i].value === '(') {\n        innerBrackets.push(tokens[i].value);\n\n        if (i === 0) {\n          continue;\n        }\n      }\n    }\n\n    innerTokens.push(tokens[i]);\n  }\n\n  return { tokens: innerTokens, i: i - 1 };\n}\n","import { ExecuteFunction, ExecuteOperator } from './Functions';\nimport { CreateNodesFromTokens } from './NodeGenerator';\n\nexport function EvaluateTokens(tokens, input) {\n  const nodes = CreateNodesFromTokens(tokens);\n  let result = '';\n  for (const node of nodes) {\n    result += EvaluateNode(node, input);\n  }\n  return result;\n}\n\nfunction EvaluateNode(node, input) {\n  if (!node) {\n    return '';\n  }\n  if (node.type === 'operator') {\n    const parameters = node.innerNodes.map(x => EvaluateNode(x, input));\n    return ExecuteOperator(node.value, parameters);\n  } else if (node.type === 'function') {\n    const parameters = node.innerNodes.map(x => EvaluateNode(x, input));\n    return ExecuteFunction(node.value, parameters);\n  } else if (node.type === 'reference') {\n    return input[node.value] || '';\n  } else if (node.type === 'string') {\n    return node.value;\n  } else if (node.type === 'number') {\n    return node.value;\n  }\n  return '';\n}\n\nexport function GetReferencesFromTokens(tokens) {\n  return tokens\n    .filter(x => x.type === 'reference-name')\n    .map(x => x.value)\n    .filter((v, i, a) => a.indexOf(v) === i); // remove duplicates\n}\n","import { useReducer } from 'react';\n\nfunction reducer(previousState, action) {\n  let state = deepClone(previousState);\n  state[action.propertyName] = action.value;\n  return state;\n}\n\nexport function useForm(initialState) {\n  const [formState, dispatch] = useReducer(reducer, initialState);\n  const setValue = (propertyName, value) => {\n    dispatch({ propertyName, value });\n  };\n  return [formState, setValue];\n}\n\nfunction deepClone(obj) {\n  if (!obj) {\n    return null;\n  }\n  return JSON.parse(JSON.stringify(obj));\n}\n","import React, { useState } from 'react';\nimport { Helmet } from 'react-helmet';\nimport Layout from '../../../../components/layout';\nimport { FormulaEditor } from '../../../../examples/formula-parser-in-javascript/FormulaEditor';\nimport { EvaluateTokens, GetReferencesFromTokens } from '../../../../examples/formula-parser-in-javascript/Evaluator';\nimport { useForm } from '../../../../examples/formula-parser-in-javascript/useForm';\nimport './Example.scss';\n\nexport default () => {\n  const [formula, setFormula] = useState(`\"Hello \" & [First Name] & \"! \" & Round(1.2 + [Some Number])`);\n  const [errors, setErrors] = useState([]);\n  const [tokens, setTokens] = useState([]);\n  const [inputValues, setInputValue] = useForm({\n    'First Name': 'Andrew',\n    'Some Number': 3,\n  });\n\n  const references = GetReferencesFromTokens(tokens);\n  const result = EvaluateTokens(tokens, inputValues);\n\n  return (\n    <Layout>\n      <Helmet>\n        <title>Parser Example</title>\n      </Helmet>\n      <div className=\"formula-example\">\n        <p>\n          This is an example for the <a href=\"/posts/formula-parser-in-javascript\">Write a simple formula parser in JavaScript</a> post.\n        </p>\n        <p>This shows the editor, validator and evaluator all working together.</p>\n\n        <h3>Editor</h3>\n        <FormulaEditor value={formula} onChange={setFormula} onErrorsChanged={setErrors} onTokensChanged={setTokens} />\n        {errors.map((error, i) => (\n          <div key={i} className=\"error\">\n            {error.error}\n          </div>\n        ))}\n        {references.length > 0 ? <h3>References</h3> : null}\n        {references.map(x => (\n          <div key={x} className=\"input-value\">\n            <div>{x}</div>\n            <input value={inputValues[x] || ''} onChange={e => setInputValue(x, e.target.value)} />\n          </div>\n        ))}\n        <h3>Result</h3>\n        <div className=\"result\">{result}</div>\n      </div>\n    </Layout>\n  );\n};\n"],"sourceRoot":""}